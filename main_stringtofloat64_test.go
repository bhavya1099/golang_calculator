// ********RoostGPT********
/*
Test generated by RoostGPT for test java-report-test using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=stringToFloat64_d38659cd50
ROOST_METHOD_SIG_HASH=stringToFloat64_44e80853e6

FUNCTION_DEF=func stringToFloat64(str string) float64
Scenario 1: Successful Conversion of String to Float64

Details:
    Description: This test is meant to verify that the function stringToFloat64 correctly converts valid string inputs to float64 data types.
Execution:
    Arrange: Set up a valid, convertible string input such as "1234.5678".
    Act: Invoke stringToFloat64 function with the pre-set string.
    Assert: Use Go testing facilities to verify that the function returns the correct float64 value 1234.5678.
Validation:
    The choice of assertion is based on the expected normal functioning of the strconv.ParseFloat library function. The expected result is direct and straightforward as it corresponds to the input string's numerical value, after proper conversion. This test scenario is crucial as it validates the basic functionality of the function.

Scenario 2: Invalid String Input

Details:
    Description: This scenario checks how the function stringToFloat64 handles and reacts to invalid string input that can't be converted to float64.
Execution:
    Arrange: Provide a string input that can't be converted to a float64, such as "notANumber".
    Act: Invoke stringToFloat64 function with the invalid string.
    Assert: Since the function is set to terminate the program with the exit code 2 in case of an error, the Go testing facilities can catch this by checking if the function call lead to a sudden termination with the correct code.
Validation:
    This test scenario is essential in checking the robustness of the error handling mechanisms put in place by the function. If a user provides a wrong input, the function should not proceed and should be able to exit smoothly with a meaningful error code.

Scenario 3: Large Float Numbers

Details:
    Description: This test should verify whether the function can handle the conversion of large numbers that exceed the normal float64 range.
Execution:
    Arrange: Set up a string presenting a number larger than what a float64 can accommodate, such as "1.8e308".
    Act: Call the function stringToFloat64 with the preset string.
    Assert: Since float64 can only accommodate up to about 1.8e308, Go test should verify that the function returns +Inf.
Validation:
    The test is crucial for determining the functionality of the function when faced with extremes, testing the boundaries of the function.

Scenario 4: Testing Zero and Negative Values

Details:
    Description: This test should check if the function correctly handles both zero and negative values.
Execution:
    Arrange: Set up two string inputs, one as "0" and another as "-123.456".
    Act: In two separate test cases, call the function stringToFloat64 with the two preset strings.
    Assert: Go testing should verify that the function returns 0 and -123.456 for each respective call.
Validation:
    This scenario will ensure that the function can handle and correctly process both zero and negative values, important for its full functionality.
*/

// ********RoostGPT********

package calc

import (
	"fmt"
	"os"
	"strconv"
	"testing"
)

func TestStringToFloat64(t *testing.T) {

	type test struct {
		name     string
		input    string
		expected float64
		err      bool
	}
	tests := []test{
		{"Successful Conversion", "1234.5678", 1234.5678, false},
		{"Invalid Input", "notANumber", 0, true},
		{"Large Float Value", "1.8e308", 0, true},
		{"Zero Value", "0", 0, false},
		{"Negative Value", "-123.456", -123.456, false},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					t.Logf("Panic encountered so failing test %s. %v", tc.name, r)
					t.Fail()
				}
			}()

			result := stringToFloat64(tc.input)

			if tc.err {

				t.Fatalf("Expected to panic with %s but didn't", tc.input)
			} else {
				if tc.expected != result {
					t.Fatalf("Expected %f but got %f", tc.expected, result)
				}
			}
		})
	}
}
func stringToFloat64(str string) float64 {
	f, err := strconv.ParseFloat(str, 64)
	if err != nil {
		fmt.Println(err)
		os.Exit(2)
	}
	return f
}
